package gen

import (
	"fmt"
	"go/types"
	"strconv"
	"strings"

	"github.com/dimes/dihedral/resolver"
	"github.com/pkg/errors"
)

const (
	providerReturnValueName = "returnValue"
)

// GeneratedModuleProvider is a single generated provider method on the component
// from a module source
type GeneratedModuleProvider struct {
	generatedComponentType     string
	generatedComponentReceiver string
	resolvedType               *resolver.ModuleResolvedType
	assignments                []Assignment
	dependencies               []*injectionTarget
}

// NewGeneratedProvider generates a provider function for the given resolved type
// The generated function has the form:
//
// func (generatedComponent *GeneratedComponent) provides_Name() *SomeType {
//     return someModule.providerFunc(
//	       component.provides_ProvidedType(),
//         InjectableFactory(component),
//     )
// }
func NewGeneratedProvider(
	generatedComponentType string,
	generatedComponentReceiver string,
	resolvedType *resolver.ModuleResolvedType,
	providers map[string]resolver.ResolvedType,
	bindings map[string]*types.Named,
) (*GeneratedModuleProvider, error) {
	assignments := make([]Assignment, 0)
	dependencies := make([]*injectionTarget, 0)
	signature := resolvedType.Method.Type().(*types.Signature)
	for i := 0; i < signature.Params().Len(); i++ {
		param := signature.Params().At(i)
		assignment, err := AssignmentForFieldType(generatedComponentReceiver, param.Type(), providers, bindings)
		if err != nil {
			return nil, errors.Wrapf(err, "Error generating binding for %+v", resolvedType)
		}

		assignments = append(assignments, assignment)
		dependencies = append(dependencies, newInjectionTarget(param.Type()))
	}

	return &GeneratedModuleProvider{
		generatedComponentType:     generatedComponentType,
		generatedComponentReceiver: generatedComponentReceiver,
		resolvedType:               resolvedType,
		assignments:                assignments,
		dependencies:               dependencies,
	}, nil
}

// ToSource returns the source code for this provider.
func (g *GeneratedModuleProvider) ToSource(componentPackage string) string {
	moduleVariableName := SanitizeName(g.resolvedType.Module.Name)
	returnType := "target_pkg." + g.resolvedType.Name.Obj().Name()
	if g.resolvedType.IsPointer {
		returnType = "*" + returnType
	}

	var builder strings.Builder
	builder.WriteString("// MAXMAX-provider Code generated by go generate; DO NOT EDIT.\n")
	builder.WriteString("package " + componentPackage + "\n")

	imports := map[string]string{
		g.resolvedType.Name.Obj().Pkg().Path(): "target_pkg",
	}

	for _, assignment := range g.assignments {
		castTo := assignment.CastTo()
		if castTo == nil {
			continue
		}

		packagePath := castTo.Obj().Pkg().Path()
		if importName := imports[packagePath]; importName == "" {
			imports[packagePath] = "di_import_" + strconv.Itoa(len(imports)+1)
		}
	}

	builder.WriteString("import (\n")
	for packagePath, importName := range imports {
		builder.WriteString("\t" + importName + " \"" + packagePath + "\"\n")
	}
	builder.WriteString(")\n")

	builder.WriteString(
		"func (" + g.generatedComponentReceiver + " *" + g.generatedComponentType + ") " +
			ProviderName(g.resolvedType.Name) + "() (" + returnType + ", error) {\n")

	for i, assignment := range g.assignments {
		varName := fmt.Sprintf("param%d", i)
		builder.WriteString("\t" + varName + ", err := " + assignment.GetSourceAssignment() + "\n")
		builder.WriteString("\tif err != nil {\n")
		builder.WriteString("\t\tvar zeroValue " + returnType + "\n")
		builder.WriteString("\t\treturn zeroValue, err\n")
		builder.WriteString("\t}\n")
	}

	returnAssignment := providerReturnValueName
	if g.resolvedType.HasError {
		returnAssignment = returnAssignment + ", err"
	}

	builder.WriteString(
		"\t" + returnAssignment + " := " + g.generatedComponentReceiver +
			"." + moduleVariableName + "." + g.resolvedType.Method.Name() + "(\n")

	for i := range g.assignments {
		varName := fmt.Sprintf("param%d", i)
		builder.WriteString("\t\t" + varName + ",\n")
	}
	builder.WriteString("\t)\n")

	builder.WriteString("\treturn " + providerReturnValueName)
	if g.resolvedType.HasError {
		builder.WriteString(", err\n")
	} else {
		builder.WriteString(", nil\n")
	}

	builder.WriteString("}\n")
	return builder.String()
}
